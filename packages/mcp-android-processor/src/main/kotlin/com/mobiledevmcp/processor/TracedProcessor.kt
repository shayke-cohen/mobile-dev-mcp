/**
 * KSP Processor for @Traced annotation
 * 
 * Generates traced wrapper functions at compile time.
 */
package com.mobiledevmcp.processor

import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.*
import com.google.devtools.ksp.validate
import java.io.OutputStream

/**
 * KSP Processor that generates tracing code for @Traced annotated classes and functions.
 */
class TracedProcessor(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger,
    private val options: Map<String, String>
) : SymbolProcessor {

    override fun process(resolver: Resolver): List<KSAnnotated> {
        val symbols = resolver.getSymbolsWithAnnotation("com.mobiledevmcp.annotations.Traced")
        val unprocessed = symbols.filter { !it.validate() }.toList()
        
        symbols
            .filter { it is KSClassDeclaration && it.validate() }
            .forEach { processClass(it as KSClassDeclaration) }
        
        symbols
            .filter { it is KSFunctionDeclaration && it.validate() }
            .forEach { processFunction(it as KSFunctionDeclaration) }
        
        return unprocessed
    }

    private fun processClass(classDecl: KSClassDeclaration) {
        val className = classDecl.simpleName.asString()
        val packageName = classDecl.packageName.asString()
        
        logger.info("Processing @Traced class: $packageName.$className")
        
        // Get the @Traced annotation
        val tracedAnnotation = classDecl.annotations.find { 
            it.shortName.asString() == "Traced" 
        }
        
        // Get annotation parameters
        val nameOverride = tracedAnnotation?.arguments?.find { it.name?.asString() == "name" }
            ?.value as? String ?: ""
        val includeArgs = tracedAnnotation?.arguments?.find { it.name?.asString() == "includeArgs" }
            ?.value as? Boolean ?: true
        
        // Generate extension file with tracing wrappers
        val fileName = "${className}TracingExtensions"
        val file = codeGenerator.createNewFile(
            dependencies = Dependencies(true, classDecl.containingFile!!),
            packageName = packageName,
            fileName = fileName
        )
        
        file.write(generateTracingExtensions(classDecl, nameOverride, includeArgs))
        file.close()
    }

    private fun processFunction(funcDecl: KSFunctionDeclaration) {
        // For standalone functions, we generate a traced version
        val funcName = funcDecl.simpleName.asString()
        val packageName = funcDecl.packageName.asString()
        
        logger.info("Processing @Traced function: $packageName.$funcName")
        
        // For now, we just log - full implementation would generate wrapper code
    }

    private fun generateTracingExtensions(
        classDecl: KSClassDeclaration,
        namePrefix: String,
        includeArgs: Boolean
    ): ByteArray {
        val className = classDecl.simpleName.asString()
        val packageName = classDecl.packageName.asString()
        val prefix = namePrefix.ifEmpty { className }
        
        val builder = StringBuilder()
        
        // Package declaration
        builder.appendLine("/**")
        builder.appendLine(" * Auto-generated tracing extensions for $className")
        builder.appendLine(" * Generated by MCP KSP Processor")
        builder.appendLine(" */")
        builder.appendLine("@file:Suppress(\"unused\")")
        builder.appendLine()
        builder.appendLine("package $packageName")
        builder.appendLine()
        builder.appendLine("import com.mobiledevmcp.MCPBridge")
        builder.appendLine()
        
        // Get all public functions that aren't excluded
        val functions = classDecl.getAllFunctions()
            .filter { it.isPublic() }
            .filter { func ->
                !func.annotations.any { it.shortName.asString() == "TraceExclude" }
            }
            .filter { it.simpleName.asString() !in listOf("equals", "hashCode", "toString", "copy") }
            .toList()
        
        if (functions.isEmpty()) {
            builder.appendLine("// No public functions to trace in $className")
            return builder.toString().toByteArray()
        }
        
        // Generate a static object with trace helpers
        builder.appendLine("/**")
        builder.appendLine(" * Tracing utilities for $className")
        builder.appendLine(" */")
        builder.appendLine("object ${className}Tracing {")
        builder.appendLine("    private const val CLASS_NAME = \"$prefix\"")
        builder.appendLine()
        
        for (func in functions) {
            val funcName = func.simpleName.asString()
            val params = func.parameters
            
            // Generate trace start helper
            builder.appendLine("    /**")
            builder.appendLine("     * Start trace for $funcName")
            builder.appendLine("     */")
            builder.appendLine("    @JvmStatic")
            builder.appendLine("    fun trace${funcName.replaceFirstChar { it.uppercase() }}(${generateParamList(params, includeArgs)}) {")
            builder.appendLine("        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.JELLY_BEAN && !com.mobiledevmcp.BuildConfig.DEBUG) return")
            
            if (includeArgs && params.isNotEmpty()) {
                val argsMap = params.joinToString(", ") { p -> 
                    "\"${p.name?.asString()}\" to ${p.name?.asString()}" 
                }
                builder.appendLine("        MCPBridge.trace(\"\$CLASS_NAME.$funcName\", mapOf($argsMap))")
            } else {
                builder.appendLine("        MCPBridge.trace(\"\$CLASS_NAME.$funcName\")")
            }
            builder.appendLine("    }")
            builder.appendLine()
            
            // Generate trace end helper
            builder.appendLine("    /**")
            builder.appendLine("     * End trace for $funcName")
            builder.appendLine("     */")
            builder.appendLine("    @JvmStatic")
            builder.appendLine("    fun traceEnd${funcName.replaceFirstChar { it.uppercase() }}(result: Any? = null, error: String? = null) {")
            builder.appendLine("        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.JELLY_BEAN && !com.mobiledevmcp.BuildConfig.DEBUG) return")
            builder.appendLine("        MCPBridge.traceReturn(\"\$CLASS_NAME.$funcName\", result, error)")
            builder.appendLine("    }")
            builder.appendLine()
        }
        
        builder.appendLine("}")
        
        return builder.toString().toByteArray()
    }

    private fun generateParamList(params: Sequence<KSValueParameter>, includeArgs: Boolean): String {
        if (!includeArgs || params.none()) return ""
        
        return params.mapNotNull { param ->
            val name = param.name?.asString() ?: return@mapNotNull null
            val type = param.type.resolve().declaration.simpleName.asString()
            "$name: $type"
        }.joinToString(", ")
    }

    private fun KSFunctionDeclaration.isPublic(): Boolean {
        return modifiers.none { it == Modifier.PRIVATE || it == Modifier.PROTECTED || it == Modifier.INTERNAL }
    }
}

/**
 * Provider for the TracedProcessor
 */
class TracedProcessorProvider : SymbolProcessorProvider {
    override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor {
        return TracedProcessor(
            codeGenerator = environment.codeGenerator,
            logger = environment.logger,
            options = environment.options
        )
    }
}

// Extension to write bytes to OutputStream
private fun OutputStream.write(bytes: ByteArray) {
    write(bytes)
}
